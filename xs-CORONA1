#!/bin/bash
# <TAGS> epidemiology </TAGS>

################################################################################
# INTIAL VARIABLE DEFINITIONS
################################################################################
# for most scripts...
thisprog=`basename "$0"`
progpath=$(dirname $(readlink -f "$0"))
progbase1=$(echo $thisprog | awk -F - '{print toupper($NF)}')
allopts=$@
tempfile="temp_"$thisprog #"."$$"."
startdir=$(pwd)
start_time=$(date +'%s.%3N')
date0=$(date)
# colours for use with text printed to terminal
RED='\033[0;31m'	# for errors
PURPLE='\033[0;35m'	# for warnings
GREEN='\033[0;32m'	# for interactive text requiring input
NC='\033[0m' 		# to revert to default text colour
# options
setverb="0"
setclean="1"

seturl="https://opendata.ecdc.europa.eu/covid19/casedistribution/csv"
setcountries="United_Kingdom"
setmindeaths="0"
setmaxweeks="0"
setlo="0"
sethi="0.5"

################################################################################
# PRINT INSTRUCTIONS IF NO ARGUMENTS ARE GIVEN
################################################################################
if [ $# -lt 1 ]; then
	echo
	echo "--------------------------------------------------------------------------------"
	echo $thisprog": template BASH script"
	echo "USAGE: $thisprog [mode] [options]"
	echo "	[mode]: operating mode: download | run"
	echo "VALID OPTIONS (defaults in []):"
	echo "	-d: minimum cumulative deaths (begin analysis) [$setmindeaths]"
	echo "	-w: maximum weeks since --mindeaths was reached (end analysis) [$setmaxweeks]"
	echo "	--countries: CSV list of countries to analyse [$setcountries]"
	echo "	--lo: butterworth low-cut frequency (weeks) [$setlo]"
	echo "	--hi: butterworth high-cut frequency (weeks) [$sethigh]"
	echo "	--verb: verbose output (0=NO 1=YES) [$setverb]"
	echo "	--clean: remove temporary files (0=NO 1=YES) [$setclean]"
	echo "EXAMPLE: "
	echo "	list=\"United_Kingdom,France,Germany,Italy,Spain\""
	echo "	$thisprog all --countries \$list -d 10 -w 12"
	echo "--------------------------------------------------------------------------------"
	echo
	exit
fi

########################################################################################
# INPUT FILE(S) AND ARGUMENT HANDLING
########################################################################################
setmode=$1 ; shift
#if [ ! -e "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: missing file $infile\n" ;  exit; } ; fi
#if [ ! -s "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: $infile is empty\n" ;  exit; } ; fi

vs="v:c:d:w:" ; vl="verb:,clean:,countries:,lo:,hi:"
y=$(getopt -o $vs -l $vl -n "" -- "$@" 2>&1 > /dev/null)
if [ "$y" != "" ] ; then { echo -e "\n--- Error ["$thisprog"]"$y"\n" ; exit ; }
else eval set -- $(getopt -o $vs -l $vl -n "" -- "$@") ; fi
while [ $# -gt 0 ] ; do
	case $1 in
		-v | --verb ) setverb=$2 ; shift ;;
		-c | --clean ) setclean=$2 ; shift ;;
		-d ) setmindeaths=$2 ; shift ;;
		-w ) setmaxweeks=$2 ; shift ;;
		--countries ) setcountries=$2 ; shift ;;
		--lo ) setlo=$2 ; shift ;;
		--hi ) sethi=$2 ; shift ;;
		-- ) shift ; break ;;
		* ) ;;
	esac
	shift
done
if [ "$setverb" != "0" ] && [ "$setverb" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --verb ($setverb) -  must be 0 or 1\n" ;  exit; } ; fi
if [ "$setclean" != "0" ] && [ "$setclean" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --clean ($setclean) -  must be 0 or 1\n" ;  exit; } ; fi
if [ $setverb == 1 ] ; then
	echo -e "--------------------------------------------------------------------------------\n"$thisprog" "$allopts"\n"
	echo -e "$date0"
fi

# convert weeks to days
let setmaxdays=$(echo "$setmaxweeks * 7" | bc | cut -f 1 -d .)

rm -f jj.*

################################################################################
# DOWNLOAD AND CREATE TEXT FILE
if [ "$setmode" == "all" ] || [ "$setmode" == "down" ] ; then

	# download file - rename from "csv" to covid_[date].csv
	# ...where date is derived from the flie timestamp
	wget -O csv -q --show-progress  $seturl
	basename="covid_"$(ls -l csv  --time-style="+%Y%m%d" | awk '{print $6}' | cut -f 1 -d /)
	mv csv $basename".csv"
	ls -l *.csv

	# save the header with renamed variables, convert commas and spaces
	head -n 1 $basename".csv" |
		xe-strsub1 stdin dateRep Date |
		xe-strsub1 stdin cases Cases |
		xe-strsub1 stdin deaths Deaths |
		xe-strsub1 stdin countriesAndTerritories Country |
		xe-strsub1 stdin geoId GeoID |
		xe-strsub1 stdin countryterritoryCode Code |
		xe-strsub1 stdin popData2018 Pop |
		xe-strsub1 stdin continentExp Continent |
		tr ',' '\t' |
		tr ' ' '_'  > jj.header
	tail -n +2 $basename".csv" |
		xe-strsub1 stdin ',,,' ',-,-,' | # pad e double-empty fields fr countries with no GeoID and Code
		xe-strsub1 stdin 'N/A' '-' | # treat as "missing"
		grep -v "Saint Eustatius" | # problematic due to comma in name
		tr ' ' '\t' |
		tr ',' '\t' |
		tr ' ' '_' |
		tr -d '"' > jj.1

	# sort the file by date and convert date format
	# the following is organised to be robust against changes in the order of the columns in the csv file
	listcols="Date,Cases,Deaths,Country,GeoID,Code,Pop,Continent"
	cat jj.header | xe-cut1 stdin $listcols > $basename".txt"
	cat jj.header jj.1 | #xe-dbmatch1 stdin GeoID -,N/A -m -2 |
		xe-cut1 stdin $listcols -o 1 |
		xe-dateconv1 stdin -h 0 -i 1 -o 4 |
		sort -k1,1n |
		xe-dateconv1 stdin -h 0 -i 4 -o 3  >> $basename".txt"

	echo "done downloading"
	head $basename.txt
fi


################################################################################
# PROCESS THE LATEST DATA
if [ "$setmode" == "all" ] || [ "$setmode" == "proc" ] ; then

	echo 
	listcountries=$(echo $setcountries | tr ',' ' ')

	########################################
	echo -n "...determine the latest data..."
	in1=$(ls -1 "covid_"????????".txt" | tail -n 1)
	echo "	input= "$in1

	########################################
	echo "...making all-countries code-table"
	xe-cut1 $in1 GeoID,Code,Country | (head -n 1 && tail -n +2 | sort -u )  > "table_countries_all.txt"

	########################################
	echo "...initialising the slopes file"
	echo -e "code\tslope1\tslope2\tdcurrent" > jj.slopes

	########################################
	echo "...running analysis for each country..."
	let count=0
	for country in $listcountries ; do
		let count=$count+1
		code=$(xe-dbmatch1 "table_countries_all.txt" Country $country -oc Code -o 1)
		echo -e "\tCountry: "$country" ("$code")"

		#echo -e "\t\t...analyzing..."
		out2a=$tempfile"_block.txt"
		out2b="temp_xe-CORONA.txt"
		opts="-mindeaths $setmindeaths -maxdays $setmaxdays -low $setlo -high $sethi -normd 1 -normc 1 -pad 1 -out 2"

		#echo -e "\t\txe-CORONA1 $in1 $country $opts"
		xe-CORONA1 $in1 $country $opts  > $out2a

		# save the slopes
		slope1=$(grep "Regression_rising:" $out2b | xe-getkey stdin slope=)
		slope2=$(grep "Regression_falling:" $out2b | xe-getkey stdin slope=)
		dcurrent=$(xe-dbmatch1 temp_xs-CORONA1_block.txt Var Deaths -oc Count | tail -n 1)
		echo -e "$code\t$slope1\t$slope2\t$dcurrent" >> jj.slopes

		# make the groupnames table
		echo -e "group\tname" > "table_groupnames.txt"
		echo -e "0\tCases_Normalized" >> "table_groupnames.txt"
		echo -e "1\tDeaths" >> "table_groupnames.txt"
		echo -e "26\tFit_Rise:__$slope1" >> "table_groupnames.txt"
		echo -e "27\tFit_Fall:__$slope2" >> "table_groupnames.txt"

		#echo -e "\t\t...plotting..."
		plotopts="-cg 1 -cx 4 -cy 3 -line 1 -ps 0 -xint 1 -yint 10 -xscale .45 -vline 0 -xpad 0 -ypad 0 -hline $dcurrent"
		plotfile="plot_"$count".ps"
		plotlist=$plotlist" "$plotfile

		xe-plottable1 $out2a $plotopts -title "$country" -xlabel "Weeks" -ylabel "% of Peak" -legend 1 -out $plotfile
		xs-plotmod1 $plotfile --out 1 --legend "table_groupnames.txt"

	done

	xe-plotmerge1 $plotlist -xo 80 -xmax 2 -ymax 3 -xinc 280 -yinc 250 -out "plot_summary"
	rm -f $plotlist


	# MAKE THE SLOPES PLOTS
	echo "...making slope-plots..."
	plotlist=""
	let ncountries=$(tail -n +2 jj.slopes | wc -l)
	xscale=$(echo "scale=3; 0.05 * $ncountries" | bc | awk '{s=$1; if(s>.9)s=.9; print s}')
	plotopts="-cx 1 -cg 3 -cy 3 -xint 1 -pt box -xscale $xscale -legend 2 -pal inferno -frame 1"

	# 1. SLOPE OF RISE TO PEAK
	# build a slopes data file sorted by ascending (steeper) slopes
	xe-cut1 jj.slopes code,slope1 > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > "table_slopes_pre.txt"
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 "table_slopes_pre.txt" xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_pre.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 "table_slopes_pre.txt" $plotopts -xlabel "Country" -ylabel "% of Peak / Day" -title "Deaths: slope of rise" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1

	# 2. SLOPE OF FALL FROM PEAK
	# build a slopes data file sorted by descending (steeper) slopes, and converting to absolute values
	xe-cut1 jj.slopes code,slope2 > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2nr | awk '{print n++"\t"$0}' ) |
		xe-math_abs1 stdin -cy 3 |
		xe-math_round2 stdin -c 3 -b .01 > "table_slopes_post.txt"
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 "table_slopes_post.txt" xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_post.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 "table_slopes_post.txt" $plotopts -xlabel "Country" -ylabel "% of Peak / Day" -title "Deaths: slope of fall" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1

	# 3. LAST CALCULATED DEATHS, %-OF-PEAK 
	# build a data file sorted by ascending deaths
	xe-cut1 jj.slopes code,dcurrent > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > "table_dcurrent.txt"
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 "table_dcurrent.txt" xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_deaths_latest.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 "table_dcurrent.txt" $plotopts -xlabel "Country" -ylabel "% of Peak" -title "Deaths: last measure" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1


	# MERGE THE PLOTS
	xe-plotmerge1 $plotlist -xmax 2 -xinc 280 -yinc 225 -out "plot_slopes"
	rm -f $plotlist


fi
exit




in1="owid-covid-data.csv"
isocode="GBR"
location="United Kingdom"
listvar="iso_code,location,date,total_cases,new_cases,new_deaths"

location=$1
plotlist1=""
plotlist2=""
for location in 'United_Kingdom' 'United_States' 'Italy' 'Spain' 'France' 'Germany' 'Portugal' 'Belgium' 'Netherlands' 'Switzerland' 'Norway' 'Sweden' 'Finland' 'Canada' ; do
echo $location

# make location-specific temp file
xe-cut1 $in1 $listvar -d "," |
	tr ',' '\t' |
	tr ' ' '_' |
	awk -F '\t' '{n++;if(n==1||$2=="'$location'") print $0}' |
	tr ' ' '_'  |
	xe-timestamp1 stdin -p 0 -head 1 > temp1.txt

# plot instances
plotfile="plot_counts.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-line 1 -ps 0 -cx 1 -cg 2 -cy 3 -hline 750,5000 -legend 1 -lwa .5 -xscale .4 -out $plotfile"
yl="New instances"
xl="Days since 2019-12-30"
xe-cut1 "temp1.txt" 1,new_cases,new_deaths -o 1 |
	awk '{print $1,$2,$3*1}' |
	xe-transpose1 stdin -start 2 |
	awk '{d=$1;g=$2;n=$3;if(g==2)g="cases";else g="deaths";print d,g,n}' |
	xe-plottable1 stdin $plotopts -ylabel "$yl" -xlabel "$xl" -title "$location"

plotfile="plot_count_death.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-line 1 -ps 0 -cx 1 -cy 2 -hline 750 -lwa .5 -xscale .4 -colour 1 -out $plotfile"
yl="New instances"
xl="Days since 2019-12-30"
xe-cut1 "temp1.txt" 1,new_deaths -o 1 |
	xe-plottable1 stdin $plotopts -ylabel "$yl" -xlabel "$xl" -title "Deaths only"


# power spectrum
xe-cut1 temp1.txt new_cases  | tail -n +60 | xe-fftpow2 stdin -sf 7 -u 0 | awk '{print "cases",$1,$2}' > jjj
xe-cut1 temp1.txt new_deaths | tail -n +60 | xe-fftpow2 stdin -sf 7 -u 0 | awk '{print "deaths",$1,$2}' >> jjj
plotfile="plot_power.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-cg 1 -cx 2 -cy 3 -line 1 -ps 3 -xint .5 -vline 1,2 -ymax 500 -out $plotfile"
yl="Spectral Power"
xl="Weeks"

xe-plottable1 jjj $plotopts -ylabel "$yl" -xlabel "$xl" -legend 2 -lwa .5 -title "$location: Spectrum"


# power in time
for var in new_cases  new_deaths ; do
	plotfile="plot_power_$var.ps"
	plotlist1=$plotlist1" "$plotfile
	xe-cut1 temp1.txt $var |
	xe-fftpow2 stdin -sf 7 -o 1 -w 30 -s 10 |
	xe-matrixmod1 stdin -r -90 |
	xe-plotmatrix1 stdin -ymin 0 -ymax 3.5 -yint 1 -hline 1,2 -xmax 128 -ylabel "Weeks" -xlabel "Days since 2019-12-30" -yscale .15 -out $plotfile -title "$var"
done


plotbase="plot_summary_"$location
xe-plotmerge1 $plotlist1 -xmax 2 -xinc 290 -yinc 250 -xo 80 -out $plotbase
plotlist2=$plotlist2" "$plotbase".001.ps"

plotlist1=""
rm -f $plotlist1

done

xe-plotmerge2 $plotlist2 > plot_summary_all.ps




exit








# coherence analysis
xe-cut1 temp1.txt new_cases > jj1
xe-cut1 temp1.txt new_deaths > jj2
xe-fftcoh3 jj1 jj2 -dt -1 -sf 7 -v 1 -w 14  |
	xe-plottable1 stdin -xint 1 -vline 1 -ymin 0 -ymax 1 -line 1

xe-fftcoh3 jj1 jj2 -dt -1 -sf 7 -v 1 -w 14 -o 1 |
	xe-matrixmod1 stdin -r -90 |
	xe-plotmatrix1 stdin -ymin 0 -ymax 3.5 -yint .5 -hline 1

# autocorrelogram
xe-cut1 temp1.txt new_deaths -o 1 |
	xe-autocor1 stdin -sf 1 -max 14 |
	xe-plottable1 stdin -line 1 -ps 0 -vline 7


# cross-correlogram
xe-cut1 temp1.txt new_cases,new_deaths -o 1 |
	xe-crosscor2 stdin -sf 1 -max 10 |
	xe-plottable1 stdin -vline 7 -ymin 0 -ymax  1




################################################################################
# REPORT, CLEANUP AND EXIT
################################################################################
if [ "$setverb" == "1" ] ; then
	end_time=$(date +'%s.%3N')
	s=$(echo $end_time $start_time | awk '{print $1-$2}' )
	m=$(echo $s | awk '{print ($1/60)}')
	echo "	Time to finish job: "$s" seconds = "$m" minutes"
fi
if [ "$setclean" == "1" ] ; then
	if [ "$tempfile" != "" ] ; then rm -f $tempfile* ; fi
fi
exit
