#!/bin/bash
# <TAGS> </TAGS>

################################################################################
# INTIAL VARIABLE DEFINITIONS
################################################################################
# for most scripts...
thisprog=`basename "$0"`
progpath=$(dirname $(readlink -f "$0"))
progbase1=$(echo $thisprog | awk -F - '{print toupper($NF)}')
allopts=$@
tempfile="temp_"$thisprog #"."$$"."
startdir=$(pwd)
start_time=$(date +'%s.%3N')
date0=$(date)
# colours for use with text printed to terminal
RED='\033[0;31m'	# for errors
PURPLE='\033[0;35m'	# for warnings
GREEN='\033[0;32m'	# for interactive text requiring input
NC='\033[0m' 		# to revert to default text colour
# options
setverb="0"
setclean="1"

seturl="https://opendata.ecdc.europa.eu/covid19/casedistribution/csv"
setcountries="United_Kingdom"
setmindeaths="0"
setmaxweeks="0"
setlo="0"
sethi="0.5"

################################################################################
# PRINT INSTRUCTIONS IF NO ARGUMENTS ARE GIVEN
################################################################################
if [ $# -lt 1 ]; then
	echo
	echo "--------------------------------------------------------------------------------"
	echo $thisprog": template BASH script"
	echo "USAGE: $thisprog [mode] [options]"
	echo "	[mode]: operating mode: download | run"
	echo "VALID OPTIONS (defaults in []):"
	echo "	-d: minimum cumulative deaths (begin analysis) [$setmindeaths]"
	echo "	-w: maximum weeks since --mindeaths was reached (end analysis) [$setmaxweeks]"
	echo "	--countries: CSV list of countries to analyse [$setcountries]"
	echo "	--lo: butterworth low-cut frequency (weeks) [$setlo]"
	echo "	--hi: butterworth high-cut frequency (weeks) [$sethigh]"
	echo "	--verb: verbose output (0=NO 1=YES) [$setverb]"
	echo "	--clean: remove temporary files (0=NO 1=YES) [$setclean]"
	echo "EXAMPLE: "
	echo "	"$thisprog" download --verb 1"
	echo "--------------------------------------------------------------------------------"
	echo
	exit
fi

########################################################################################
# INPUT FILE(S) AND ARGUMENT HANDLING
########################################################################################
setmode=$1 ; shift
#if [ ! -e "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: missing file $infile\n" ;  exit; } ; fi
#if [ ! -s "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: $infile is empty\n" ;  exit; } ; fi

vs="v:c:d:w:" ; vl="verb:,clean:,countries:,lo:,hi:"
y=$(getopt -o $vs -l $vl -n "" -- "$@" 2>&1 > /dev/null)
if [ "$y" != "" ] ; then { echo -e "\n--- Error ["$thisprog"]"$y"\n" ; exit ; }
else eval set -- $(getopt -o $vs -l $vl -n "" -- "$@") ; fi
while [ $# -gt 0 ] ; do
	case $1 in
		-v | --verb ) setverb=$2 ; shift ;;
		-c | --clean ) setclean=$2 ; shift ;;
		-d ) setmindeaths=$2 ; shift ;;
		-w ) setmaxweeks=$2 ; shift ;;
		--countries ) setcountries=$2 ; shift ;;
		--lo ) setlo=$2 ; shift ;;
		--hi ) sethi=$2 ; shift ;;
		-- ) shift ; break ;;
		* ) ;;
	esac
	shift
done
if [ "$setverb" != "0" ] && [ "$setverb" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --verb ($setverb) -  must be 0 or 1\n" ;  exit; } ; fi
if [ "$setclean" != "0" ] && [ "$setclean" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --clean ($setclean) -  must be 0 or 1\n" ;  exit; } ; fi
if [ $setverb == 1 ] ; then
	echo -e "--------------------------------------------------------------------------------\n"$thisprog" "$allopts"\n"
	echo -e "$date0"
fi

# convert weeks to days
let setmaxdays=$(echo "$setmaxweeks * 7" | bc | cut -f 1 -d .)

rm -f jj.*

################################################################################
# DOWNLOAD AND CREATE TEXT FILE
if [ "$setmode" == "all" ] || [ "$setmode" == "down" ] ; then

	# download file - rename from "csv" to covid_[date].csv
	# ...where date is derived from the flie timestamp
	wget -O csv -q --show-progress  $seturl
	basename="covid_"$(ls -l csv  --time-style="+%Y%m%d" | awk '{print $6}' | cut -f 1 -d /)
	mv csv $basename".csv"
	ls -l *.csv

	# save the header with renamed variables, convert commas and spaces
	head -n 1 $basename".csv" |
		xe-strsub1 stdin dateRep Date |
		xe-strsub1 stdin cases Cases |
		xe-strsub1 stdin deaths Deaths |
		xe-strsub1 stdin countriesAndTerritories Country |
		xe-strsub1 stdin geoId GeoID |
		xe-strsub1 stdin countryterritoryCode Code |
		xe-strsub1 stdin popData2018 Pop |
		xe-strsub1 stdin continentExp Continent |
		tr ',' '\t' |
		tr ' ' '_'  > jj.header
	tail -n +2 $basename".csv" |
		xe-strsub1 stdin ',,,' ',-,-,' | # pad e double-empty fields fr countries with no GeoID and Code
		xe-strsub1 stdin 'N/A' '-' | # treat as "missing"
		grep -v "Saint Eustatius" | # problematic due to comma in name
		tr ' ' '\t' |
		tr ',' '\t' |
		tr ' ' '_' |
		tr -d '"' > jj.1

	# sort the file by date and convert date format
	# the following is organised to be robust against changes in the order of the columns in the csv file
	listcols="Date,Cases,Deaths,Country,GeoID,Code,Pop,Continent"
	cat jj.header | xe-cut1 stdin $listcols > $basename".txt"
	cat jj.header jj.1 | #xe-dbmatch1 stdin GeoID -,N/A -m -2 |
		xe-cut1 stdin $listcols -o 1 |
		xe-dateconv1 stdin -h 0 -i 1 -o 4 |
		sort -k1,1n |
		xe-dateconv1 stdin -h 0 -i 4 -o 3  >> $basename".txt"

	echo "done downloading"
	head $basename.txt
fi


################################################################################
# PROCESS THE LATEST DATA
if [ "$setmode" == "all" ] || [ "$setmode" == "proc" ] ; then

	########################################
	echo "...determine the latest data..."
	in1=$(ls -1 "covid_"????????".txt" | tail -n 1)
	echo "	input= "$in1

	########################################
	echo "...making all-countries code-table"
	xe-cut1 $in1 GeoID,Code,Country | (head -n 1 && tail -n +2 | sort -u )  > "table_countries_all.txt"

	########################################
	echo "...initialising the slopes file"
	listcountries=$(echo $setcountries | tr ',' ' ')
	listcols="Date,Cases,Deaths"
	echo -e "code\tslope1\tslope2" > jj.slopes

	########################################
	echo "...running analysis for each country..."
	let count=0
	for country in $listcountries ; do
		let count=$count+1
		code=$(xe-dbmatch1 "table_countries_all.txt" Country $country -oc Code -o 1)
		echo -e "\tCountry: "$country" ("$code")"

		# select data for country, calculate cumulative deaths and days, and select on mindeaths
		echo -e "\t\t...extracting country & calculating cumulative deaths..."
		xe-dbmatch1 $in1 Country $country |
			xe-cut1 stdin $listcols |
			awk 'BEGIN{n=deaths=days=0; mindeaths=1*'$setmindeaths'}
			{
				if(++n==1) print $0"\tDay\tDeathSum";
				else { deaths+=$3; if(deaths>=mindeaths) print $0"\t"days"\t"deaths }
			}' > jj.3

		# filter the data and extract on days past peak in smoothed-deaths
		echo -e "\t\t...filtering..."
		xe-cut1 jj.3 Deaths |
			xe-filter_butterworth1 stdin -sf 7 -low $setlo -high $sethi |
			xe-timestamp1 stdin -p 0 |
			awk 'BEGIN{days=0;maxdays=1*'$setmaxdays'}{
				if(days++<=maxdays) print "1\t"$0
			}' > jj.filtdeaths
		xe-cut1 jj.3 Cases |
			xe-filter_butterworth1 stdin -sf 7  -low $setlo -high $sethi |
			xe-timestamp1 stdin -p 0 |
			awk 'BEGIN{days=0;maxdays=1*'$setmaxdays'}{
				if(days++<=maxdays) print "24\t"$0
			}' > jj.filtcases

		# find the smoothed peak and the correction factor for the cases
		echo -e "\t\t...finding peak..."
		dmax=$(cut -f 3 jj.filtdeaths | xe-statsd1 stdin -f 0 | cut -f 5) # max value, deaths
		x=$(cut -f 3 jj.filtcases | xe-statsd1 stdin -f 0 | cut -f 5) # max value, cases
		ratio=$(echo "scale=12; $dmax/$x" | bc)

		# save the deaths data for the pre-peak period
		echo -e "\t\t...getting pre-peak period..."
		awk 'BEGIN{s=1;a=1*'$dmax'}{if(s==1)print $2"\t"$3; if($3==a) s=0;}' jj.filtdeaths > jj.pre
		# calculate the regression line
		reg=$(xe-correlate jj.pre -verb 2 | grep "Regression equation:" | cut -f 2- -d :)
		x1=$(head -n 1 jj.pre | cut -f 1)
		x2=$(tail -n 1 jj.pre | cut -f 1)
		y1=$(echo $reg | awk 'BEGIN{x1=1*'$x1'}{print $3 + x1*$5}')
		y2=$(echo $reg | awk 'BEGIN{x2=1*'$x2'}{print $3 + x2*$5}')
		echo -e "26\t$x1\t$y1\n26\t$x2\t$y2" > jj.prepoints # the two points defining the fit-line
		# calculate the corrected slope - scale data 0-100
		div=$(echo "scale=12; $dmax / 100" | bc)
		xe-norm2 jj.pre -cy 2 -sub 0 -div $div > jj.prenorm # new range is  hypothetical-0 to 100
		slope1=$(xe-correlate jj.prenorm -verb 2 | grep "Regression equation:" | cut -f 2- -d : | awk '{printf("%.3f",$5)}')

		# save the deaths data for the post-peak period
		echo -e "\t\t...getting post-peak period..."
		awk 'BEGIN{s=0;a=1*'$dmax'}{if($3==a) s=1; if(s==1)print $2"\t"$3}' jj.filtdeaths > jj.post
		# calculate the regression line for the post-peak deaths data
		reg=$(xe-correlate jj.post -verb 2 | grep "Regression equation:" | cut -f 2- -d :)
		x1=$(head -n 1 jj.post | cut -f 1)
		x2=$(tail -n 1 jj.post | cut -f 1)
		y1=$(echo $reg | awk 'BEGIN{x1=1*'$x1'}{print $3 + x1*$5}')
		y2=$(echo $reg | awk 'BEGIN{x2=1*'$x2'}{print $3 + x2*$5}')
		echo -e "27\t$x1\t$y1\n27\t$x2\t$y2" > jj.postpoints # the two points defining the fit-line
		# calculate the corrected slope - scale data 0-100
		div=$(echo "scale=12; $dmax / 100" | bc)
		xe-norm2 jj.post -cy 2 -sub 0 -div $div > jj.postnorm # new range is  hypothetical-0 to 100
		slope2=$(xe-correlate jj.postnorm -verb 2 | grep "Regression equation:" | cut -f 2- -d : | awk '{printf("%.3f",$5)}')

		########################################
		echo -e "\t\t...plotting..."
		# make the country plot
		echo -e "group\tname" > "table_groupnames.txt"
		echo -e "24\tCases_Normalized" >> "table_groupnames.txt"
		echo -e "1\tDeaths" >> "table_groupnames.txt"
		echo -e "26\tFit_Rise:__$slope1" >> "table_groupnames.txt"
		echo -e "27\tFit_Fall:__$slope2" >> "table_groupnames.txt"
		plotopts="-cg 1 -cx 2 -cy 3 -line 1 -ps 0 -xint 7 -xscale .4"
		plotfile="plot_"$count".ps"
		plotlist=$plotlist" "$plotfile
		t=$country
		xe-math_mult1 jj.filtcases -cy 3 -v $ratio |
			cat jj.prepoints jj.postpoints jj.filtdeaths - |
				xe-plottable1 stdin $plotopts -title "$t" -xlabel "Days" -ylabel "Deaths" -legend 1 -out $plotfile
			xs-plotmod1 $plotfile --out 1 --legend "table_groupnames.txt"


		# save the slopes
		echo -e "$code\t$slope1\t$slope2" >> jj.slopes


	done

	xe-plotmerge1 $plotlist -xo 80 -xmax 2 -ymax 3 -xinc 280 -yinc 250 -out "plot_summary"
	rm -f $plotlist


	# MAKE THE SLOPES PLOTS
	echo "...making slope-plots..."
	plotlist=""
	let ncountries=$(tail -n +2 jj.slopes | wc -l)
	xscale=$(echo "scale=3; 0.05 * $ncountries" | bc | awk '{s=$1; if(s>.9)s=.9; print s}')
	plotopts="-cx 1 -cg 3 -cy 3 -xint 1 -pt box -xscale $xscale -legend 2 -pal inferno -frame 1"
	# 1. SLOPE OF RISE TO PEAK
	# build a slopes data file sorted by ascending (steeper) slopes
	xe-cut1 jj.slopes code,slope1 > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > "table_slopes_pre.txt"
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 "table_slopes_pre.txt" xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_pre.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 "table_slopes_pre.txt" $plotopts -xlabel "Country" -ylabel "% of Peak / Day" -title "Deaths: rise to peak" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1
	# 2. SLOPE OF FALL FROM PEAK
	# build a slopes data file sorted by descending (steeper) slopes, and converting to absolute values
	xe-cut1 jj.slopes code,slope2 > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2nr | awk '{print n++"\t"$0}' ) |
		xe-math_abs1 stdin -cy 3 |
		xe-math_round2 stdin -c 3 -b .01 > "table_slopes_post.txt"
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 "table_slopes_post.txt" xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_post.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 "table_slopes_post.txt" $plotopts -xlabel "Country" -ylabel "% of Peak / Day" -title "Deaths: fall from peak" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1
	# MERGE THE PLOTS
	xe-plotmerge1 $plotlist -xmax 1 -xinc 280 -yinc 225 -out "plot_slopes"
	rm -f $plotlist

fi
exit




in1="owid-covid-data.csv"
isocode="GBR"
location="United Kingdom"
listvar="iso_code,location,date,total_cases,new_cases,new_deaths"

location=$1
plotlist1=""
plotlist2=""
for location in 'United_Kingdom' 'United_States' 'Italy' 'Spain' 'France' 'Germany' 'Portugal' 'Belgium' 'Netherlands' 'Switzerland' 'Norway' 'Sweden' 'Finland' 'Canada' ; do
echo $location

# make location-specific temp file
xe-cut1 $in1 $listvar -d "," |
	tr ',' '\t' |
	tr ' ' '_' |
	awk -F '\t' '{n++;if(n==1||$2=="'$location'") print $0}' |
	tr ' ' '_'  |
	xe-timestamp1 stdin -p 0 -head 1 > temp1.txt

# plot instances
plotfile="plot_counts.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-line 1 -ps 0 -cx 1 -cg 2 -cy 3 -hline 750,5000 -legend 1 -lwa .5 -xscale .4 -out $plotfile"
yl="New instances"
xl="Days since 2019-12-30"
xe-cut1 "temp1.txt" 1,new_cases,new_deaths -o 1 |
	awk '{print $1,$2,$3*1}' |
	xe-transpose1 stdin -start 2 |
	awk '{d=$1;g=$2;n=$3;if(g==2)g="cases";else g="deaths";print d,g,n}' |
	xe-plottable1 stdin $plotopts -ylabel "$yl" -xlabel "$xl" -title "$location"

plotfile="plot_count_death.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-line 1 -ps 0 -cx 1 -cy 2 -hline 750 -lwa .5 -xscale .4 -colour 1 -out $plotfile"
yl="New instances"
xl="Days since 2019-12-30"
xe-cut1 "temp1.txt" 1,new_deaths -o 1 |
	xe-plottable1 stdin $plotopts -ylabel "$yl" -xlabel "$xl" -title "Deaths only"


# power spectrum
xe-cut1 temp1.txt new_cases  | tail -n +60 | xe-fftpow2 stdin -sf 7 -u 0 | awk '{print "cases",$1,$2}' > jjj
xe-cut1 temp1.txt new_deaths | tail -n +60 | xe-fftpow2 stdin -sf 7 -u 0 | awk '{print "deaths",$1,$2}' >> jjj
plotfile="plot_power.ps"
plotlist1=$plotlist1" "$plotfile
plotopts="-cg 1 -cx 2 -cy 3 -line 1 -ps 3 -xint .5 -vline 1,2 -ymax 500 -out $plotfile"
yl="Spectral Power"
xl="Weeks"

xe-plottable1 jjj $plotopts -ylabel "$yl" -xlabel "$xl" -legend 2 -lwa .5 -title "$location: Spectrum"


# power in time
for var in new_cases  new_deaths ; do
	plotfile="plot_power_$var.ps"
	plotlist1=$plotlist1" "$plotfile
	xe-cut1 temp1.txt $var |
	xe-fftpow2 stdin -sf 7 -o 1 -w 30 -s 10 |
	xe-matrixmod1 stdin -r -90 |
	xe-plotmatrix1 stdin -ymin 0 -ymax 3.5 -yint 1 -hline 1,2 -xmax 128 -ylabel "Weeks" -xlabel "Days since 2019-12-30" -yscale .15 -out $plotfile -title "$var"
done


plotbase="plot_summary_"$location
xe-plotmerge1 $plotlist1 -xmax 2 -xinc 290 -yinc 250 -xo 80 -out $plotbase
plotlist2=$plotlist2" "$plotbase".001.ps"

plotlist1=""
rm -f $plotlist1

done

xe-plotmerge2 $plotlist2 > plot_summary_all.ps




exit








# coherence analysis
xe-cut1 temp1.txt new_cases > jj1
xe-cut1 temp1.txt new_deaths > jj2
xe-fftcoh3 jj1 jj2 -dt -1 -sf 7 -v 1 -w 14  |
	xe-plottable1 stdin -xint 1 -vline 1 -ymin 0 -ymax 1 -line 1

xe-fftcoh3 jj1 jj2 -dt -1 -sf 7 -v 1 -w 14 -o 1 |
	xe-matrixmod1 stdin -r -90 |
	xe-plotmatrix1 stdin -ymin 0 -ymax 3.5 -yint .5 -hline 1

# autocorrelogram
xe-cut1 temp1.txt new_deaths -o 1 |
	xe-autocor1 stdin -sf 1 -max 14 |
	xe-plottable1 stdin -line 1 -ps 0 -vline 7


# cross-correlogram
xe-cut1 temp1.txt new_cases,new_deaths -o 1 |
	xe-crosscor2 stdin -sf 1 -max 10 |
	xe-plottable1 stdin -vline 7 -ymin 0 -ymax  1




################################################################################
# REPORT, CLEANUP AND EXIT
################################################################################
if [ "$setverb" == "1" ] ; then
	end_time=$(date +'%s.%3N')
	s=$(echo $end_time $start_time | awk '{print $1-$2}' )
	m=$(echo $s | awk '{print ($1/60)}')
	echo "	Time to finish job: "$s" seconds = "$m" minutes"
fi
if [ "$setclean" == "1" ] ; then
	if [ "$tempfile" != "" ] ; then rm -f $tempfile* ; fi
fi
exit
