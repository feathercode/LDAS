#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define thisprog "xe-filter_butterworth1"
#define TITLE_STRING thisprog" v 16: 16.March.2019 [JRH]"
#define MAXLINELEN 1000
#define MAXLABELS 1000

/*
<TAGS>signal_processing filter</TAGS>

v 16: 16.March.2019 [JRH]
	- bugfix: previous update failed to preserve n1 after passing to padding function - this is now corrected

v 16: 6.March.2019 [JRH]
	- only sample-and-hold padding allowed
	- padding function now automatically updates "nn"

v 16: 9.February.2018 [JRH]
	- allow de-meaning without re-applying the mean after filtering
	- this allows LP filtered data to sit at zero if there was a DC offset in the signal

v 16: 8.May.2017 [JRH]
	- improved verbose output

v 16: 21.September.2016 [JRH]
	- add default padding type 4 (sample-and-hold)

v 16: 30.September.2015 [JRH]
	- minor fixes for compatibility with Ubuntu
		- removed embedded nulls in (s)printf statements
		- fixed concordance of print formats with integer types
	- switch to use of off_t for all pointers

v 14: 8.April.2015 [JRH]
	- revised initialization for low-pass filter function - new function xf_filter_bworth1_f
		- this removes tendency for data to tend to zero at the edges when using the low-pass filter
		- may eliminate the need for padding
		- in fact, the padding itself may cause some edge effects, especially with tapering-to-zero if the data is offset from zero
	- de-mean option now restores mean to data after filtering if -m is set to 2
	- removed option to calculate coefficients differently (xf_filter_bworth3b_f)
	- padding
		- new padding default: edge-means (xf_padarray3_f)
		- now automatically sets pad length according to low-pass frequency interval (minimum 200 or n, whichever is smaller)
		- manual padding now cannot exceed n


v 13: 24.March.2015 [JRH]
	- minor bugfix - was possible for padding to be <2 which caused the function to return an error
	- minor bugfix - incorrect name in message generated by padding function

v 12: 23.January.2015 [JRH]
	- add options for padding type:
		1:trend-to-zero - prone to edge artefacts if amount of padding is large
		2:reverse copy of data cosine trended to zero
			- the original option, and generally most reliable
			- however can produces a jump if data is offset from zero
			- can produce artefacts if edges are mid-cycle, by suddenly reversing the trend at either edge
	- auto-padding now limited to 2 seconds, but data-length (max 200) if sample freq. is <=1
	- res default is now set to 1.4142 (root-2) - which corresponds with a standard Butterworth filter

v 11: 23.June.2014 [JRH]
	- add error report to butterworth functions if low or high pass frequency exceeds Nyquist frequency (sample-rate/2)

v 9: 21.February.2014 [JRH]
	- bugfix - remove redundant datatype variable which was being confused with setdatatype

v 8: 17.February.2014 [JRH]
	- add ability to read .bin files

v 7: 15.December.2013 [JRH]
	- add option to de-mean the data - this can be very helpful for low-pass filtering at very low frequencies, to remove edge effects

v 6: 22.November.2013 [JRH]
	- incorporate interpolation if there are any invalid data points

v 5: 7.October.2013 [JRH]
	- minor update - pad function now handles memory reallocation - passes back a pointer to data
	- removed need to pass pointer-to-pointer to filter function - this was never necessary
	- need to test this on RedHat to see if it still works!

v 4: 6.October.2013 [JRH]
	- update instruction
	- incorporate cosine-tapered padding-to-zero using xf_padarray3_f
	- use size_t for counters throughout
	- where necessary for size_t type values, replace "for" tests for <0 with while loops tests for >0
	- improved butterworth filter function xf_filter_bworth1_f now allows bandpass filtering
		- that is, the double-pass is handled by the function itself


v 2: 24.January.2013 [JRH]
	- update to use new xf_filter_bworth2_f function
		- revised version of xf_filter_bworth2
		- removed need for curve2 array
		- input array is now modified in-place
		- now deals a bit better with data at the beginning and end of the series to avoid edge effects


v 1: 14.August.2012 [JRH]
	- bugfix - changed use of fscanf to read data with fgets/sscanf, to avoid problems related to "-" and "."
*/



/* external functions start */
float *xf_readbin2_f(char *infile, off_t *parameters, char *message);
float *xf_padarray1_f(float *data, long nn, long npad, int type, char *message);
float *xf_padarray2_f(float *data, long nn, long npad, int type, char *message);
float *xf_padarray3_f(float *data, long nn, long npad, int type, char *message);
float *xf_padarray4_f(float *data, long *nn, long npad, int type, char *message);
int xf_filter_bworth1_f(float *X, off_t nn, float sample_freq, float setlow, float sethigh, float res, char *message);
long xf_interp3_f(float *data, long ndata);
/* external functions end */

int main (int argc, char *argv[]) {
	/* general variables */
	char infile[256],outfile[256],line[MAXLINELEN],message[MAXLINELEN];
	long i,j,k,l,m,n;
	off_t ii,jj,kk,nn;
	int v,w,x,y,z,col,colmatch;
	int sizeofchar=sizeof(char),sizeofshort=sizeof(short),sizeoflong=sizeof(long),sizeofint=sizeof(int),sizeoffloat=sizeof(float),sizeofdouble=sizeof(double);
	float a,b,c,d;
	double aa,bb,cc,dd;
	FILE *fpin,*fpout;
	/* program-specific variables */
	int baddata=0;
	off_t n1=-1,n2=-1,start,stop,npad=0,parameters[8];
	off_t datasize,startbyte,bytestoread;
	float *data1=NULL;
	double sum,mean;
	/* arguments */
	long int setpad=-1;
	int setoutpad=0, setint=1, setdemean=0, setverb=0,setdatatype=-1;
	float setsampfreq=100.0; // sample frequency of input (samples/s)
	float setlow=0.0,sethigh=0.0;  // filter cutoffs
	float setresonance=1.4142; // filter resonance setting ()

	/* PRINT INSTRUCTIONS IF THERE IS NO FILENAME SPECIFIED */
	if(argc<2) {
		fprintf(stderr,"\n");
		fprintf(stderr,"----------------------------------------------------------------------\n");
		fprintf(stderr,"%s\n",TITLE_STRING);
		fprintf(stderr,"----------------------------------------------------------------------\n");
		fprintf(stderr,"Apply a bi-quad Butterworth filter to the input\n");
		fprintf(stderr,"	- high- and low-pass filtering performed in sequence\n");
		fprintf(stderr,"	- filtering is bidirectional to avoid temporal shifting of data\n");
		fprintf(stderr,"	- non-numeric values, NAN or INF will invalidate the output\n");
		fprintf(stderr,"USAGE:\n");
		fprintf(stderr,"	%s [input] [options]\n",thisprog);
		fprintf(stderr,"	[input]: file name or \"stdin\" comprised of a single column\n");
		fprintf(stderr,"VALID OPTIONS:\n");
		fprintf(stderr,"	-dt: type of data [%d]\n",setdatatype);
		fprintf(stderr,"		-1 = ascii\n");
		fprintf(stderr,"		0-9= uchar,char,ushort,short,uint,int,ulong,long,float,double\n");
		fprintf(stderr,"	-sf: sample frequency (sample/s) [%f]\n",setsampfreq);
		fprintf(stderr,"	-low: low frequency limit, 0=NONE [%g]\n",setlow);
		fprintf(stderr,"	-high: high frequency limit, 0=NONE [%g]\n",sethigh);
		fprintf(stderr,"	-res: resonance (0.1 to sqrt(2)=1.4142) [%g]\n",setresonance);
		fprintf(stderr,"		NOTE: low values can produce ringing in the output\n");
		fprintf(stderr,"		NOTE: high values can dampen the signal\n");
		fprintf(stderr,"	-m: de-mean the data (can reduce straight-line artefacts) [%d]\n",setdemean);
		fprintf(stderr,"		0: no de-meaning\n");
		fprintf(stderr,"		1: remove the mean before filtering\n");
		fprintf(stderr,"		2: as above but re-apply the mean after filtering\n");
		fprintf(stderr,"	-pad: apply data-padding? (-1=AUTO,0=NO,>0=#SAMPLES) [%ld]\n",setpad);
		fprintf(stderr,"		- AUTO: <=n, 200, 1sec, or if -sf<=1, 200 samples\n");
		fprintf(stderr,"		- padding duplicates last sample (sample & hold)\n");
		fprintf(stderr,"	-op: output padding as well as original data (0=NO,1=YES) [%d]\n",setoutpad);
		fprintf(stderr,"	-int: interpolate across invalid data (0=NO,exit instead, 1=YES [%d]\n",setint);
		fprintf(stderr,"	-v: set verbose output (0=NO,1=YES) [%d]\n",setverb);
		fprintf(stderr,"EXAMPLES:\n");
		fprintf(stderr,"	%s data.txt -t 1\n",thisprog);
		fprintf(stderr,"	cat temp.txt | %s stdin -t 3\n",thisprog);
		fprintf(stderr,"----------------------------------------------------------------------\n");
		fprintf(stderr,"\n");
		exit(0);
	}

	/* READ THE FILENAME AND OPTIONAL ARGUMENTS */
	sprintf(infile,"%s",argv[1]);
	for(i=2;i<argc;i++) {
		if( *(argv[i]+0) == '-') {
			if((i+1)>=argc) {fprintf(stderr,"\n--- Error[%s]: missing value for argument \"%s\"\n\n",thisprog,argv[i]); exit(1);}
			else if(strcmp(argv[i],"-dt")==0)   setdatatype=atoi(argv[++i]);
			else if(strcmp(argv[i],"-sf")==0)   setsampfreq=atof(argv[++i]);
			else if(strcmp(argv[i],"-low")==0)  setlow=atof(argv[++i]);
			else if(strcmp(argv[i],"-high")==0) sethigh=atof(argv[++i]);
			else if(strcmp(argv[i],"-m")==0)    setdemean=atoi(argv[++i]);
			else if(strcmp(argv[i],"-res")==0)  setresonance=atof(argv[++i]);
			else if(strcmp(argv[i],"-pad")==0)  setpad=atol(argv[++i]);
			else if(strcmp(argv[i],"-op")==0)   setoutpad=atoi(argv[++i]);
			else if(strcmp(argv[i],"-int")==0)  setint=atoi(argv[++i]);
			else if(strcmp(argv[i],"-v")==0)    setverb=atoi(argv[++i]);
			else {fprintf(stderr,"\n--- Error[%s]: invalid command line argument \"%s\"\n\n",thisprog,argv[i]); exit(1);}
	}}

	if(setsampfreq<=0) {fprintf(stderr,"\n--- Error[%s]: sample frequency (-sf %g) must be > 0\n\n",thisprog,setsampfreq);exit(1);};
	if(setlow<0) {fprintf(stderr,"\n--- Error[%s]: low frequency cutoff (-low %g) must be >= 0 \n\n",thisprog,setlow);exit(1);};
	if(sethigh<0) {fprintf(stderr,"\n--- Error[%s]: high frequency cutoff (-high %g) must be >= 0 \n\n",thisprog,sethigh);exit(1);};
	if(setpad<0&&setpad!=-1) {fprintf(stderr,"\n--- Error[%s]: padding option (-pad %ld) must be -1, 0 or >0\n\n",thisprog,setpad);exit(1);};
	if(setoutpad!=0 && setoutpad!=1) {fprintf(stderr,"\n--- Error[%s]: -op option (%d) must be 0 or 1 \n\n",thisprog,setoutpad);exit(1);};
	if(setint!=0 && setint!=1) {fprintf(stderr,"\n--- Error[%s]: -int option (%d) must be 0 or 1 \n\n",thisprog,setint);exit(1);};
	if(setdemean!=0 && setdemean!=1 && setdemean!=2) {fprintf(stderr,"\n--- Error[%s]: -m option (%d) must be 0 1 or 2\n\n",thisprog,setdemean);exit(1);};
	if(setverb!=0 && setverb!=1) {fprintf(stderr,"\n--- Error[%s]: -v option (%d) must be 0 or 1 \n\n",thisprog,setverb);exit(1);};

	if(setdatatype==0||setdatatype==1) datasize=(off_t)sizeof(char);
	else if(setdatatype==2||setdatatype==3) datasize=(off_t)sizeof(short);
	else if(setdatatype==4||setdatatype==5) datasize=(off_t)sizeof(int);
	else if(setdatatype==6||setdatatype==7) datasize=(off_t)sizeof(long);
	else if(setdatatype==8) datasize=(off_t)sizeof(float);
	else if(setdatatype==9) datasize=(off_t)sizeof(double);
	else if(setdatatype!=-1) {fprintf(stderr,"\n--- Error[%s]: data type (-t %d) must be -1 (ascii) or 0-9 \n\n",thisprog,setdatatype); exit(1);}

	if(setverb==1) {
		fprintf(stderr,"\tinfile=%s\n",infile);
		fprintf(stderr,"\thigh_cut=%g\n",sethigh);
		fprintf(stderr,"\tlow_cut=%g\n",setlow);
	}


	/********************************************************************************/
	/* STORE RAW DATA  */
	/********************************************************************************/
	if(setverb==1) fprintf(stderr,"\tstoring data...\n");
	if(setdatatype==-1) {
		if(strcmp(infile,"stdin")==0) fpin=stdin;
		else if((fpin=fopen(infile,"r"))==0) {fprintf(stderr,"\n--- Error[%s]: file \"%s\" not found\n\n",thisprog,infile);exit(1);}
		n1=0;baddata=0;
		while(fgets(line,MAXLINELEN,fpin)!=NULL) {
			if(sscanf(line,"%f",&a)!=1) a=NAN;
			if((data1=(float *)realloc(data1,(n1+1)*sizeoffloat))==NULL) {fprintf(stderr,"\n--- Error[%s]: insufficient memory\n\n",thisprog);exit(1);};
			if(!isfinite(a)) baddata=1;
			data1[n1++]= a;
		}
		if(strcmp(infile,"stdin")!=0) fclose(fpin);
		n2= n1;
	}
	else if(setdatatype>=0 && setdatatype <=9) {
		parameters[0]= setdatatype;
		parameters[1]= 0; // header-bytes
		parameters[2]= 0; // numbers to skip
		parameters[3]= 0; // if set to zero, will read all available bytes after the header+(start*datasize)
		data1= xf_readbin2_f(infile,parameters,message);
		n1=n2= parameters[3]; // parameters[3] is reset to the number of elements (bytes/datasize) by xf_readbin2_f
		if(data1==NULL) {fprintf(stderr,"\n--- Error[%s]: %s\n\n",thisprog,message);exit(1);}
	}

	/********************************************************************************
	WARN, OUTPUT & EXIT IF THERE ARE TOO FEW DATA POINTS TO ACTUALLY FILTER
	********************************************************************************/
	if(n1==0){
		fprintf(stderr,"\n--- Error[%s]: input \"%s\" is empty\n\n",thisprog,infile);
		exit(1);
	}
	else if(n1<4) {
		for(ii=0;ii<n1;ii++) printf("%g\n",data1[ii]);
		if(data1!=NULL) free(data1);
		fprintf(stderr,"--- Warning[%s]: input \"%s\" has less than 4 data points - no filtering performed\n",thisprog,infile);
		exit(0);
	}
	else if(setverb==1) fprintf(stderr,"\toriginal_n1=%ld\n",n1);

	/********************************************************************************/
	/* INTERPOLATE IF THERE ARE INVALID DATAPOINTS */
	/********************************************************************************/
	if(baddata==1) {
		if(setverb==1) fprintf(stderr,"\tinterpolating...\n");
		if(setint==1) {
			k= xf_interp3_f(data1,(off_t)n1);
			if(k<0) {
				fprintf(stderr,"\n\t --- Error [%s]: input \"%s\" contains no valid numbers\n\n",thisprog,infile);
				free(data1);
				exit(1);
			}
		}
		else {
				fprintf(stderr,"\n\t --- Error [%s]: input \"%s\" contains invalid numbers - use interpolation option -int\n\n",thisprog,infile);
				free(data1);
				exit(1);
		}
	}

	/********************************************************************************
	DE-MEAN THE DATA
	********************************************************************************/
	mean= NAN;
	if(setdemean>0) {
		if(setverb==1) fprintf(stderr,"\tde-meaning the data...\n");
		sum=0.0;
		for(ii=0;ii<n1;ii++) sum+=data1[ii];
		mean= sum/(double)n1;
		for(ii=0;ii<n1;ii++) data1[ii]-=mean;
	}

	/********************************************************************************
	PAD THE DATA
	********************************************************************************/
	/* automatic padding selection: */
	if(setpad<0) {
		npad=0;
		if(sethigh>0) npad=(off_t)(setsampfreq/sethigh);
		if(npad<200) npad=200;
		if(npad>n1) npad=n1;
	}
	/* user-specified amount of padding */
	else if(setpad>0) { npad=setpad; if(npad>n1) npad=n1; }
	/* no padding */
	else npad=0;

 	/* apply the padding (end only) */
 	if(npad>0) {
		if(setverb==1) fprintf(stderr,"\tpadding=%ld\n",npad);

		n2= n1;
		data1= xf_padarray4_f(data1,&n2,npad,2,message);

		if(data1==NULL) {fprintf(stderr,"\n\t --- Error [%s]: %s\n\n\n",thisprog,message);free(data1);exit(1);}
		if(setverb==1) fprintf(stderr,"\tpadded_n2=%ld\n",n1);
	}

	/********************************************************************************
	APPLY THE FILTER
	********************************************************************************/
	if(setverb==1) fprintf(stderr,"\tfiltering...\n");
	i= xf_filter_bworth1_f(data1,n2,setsampfreq,setlow,sethigh,setresonance,message);

	if(i<0) {
		fprintf(stderr,"\n\t --- Error [%s]: %s\n\n\n",thisprog,message);
		free(data1);
		exit(1);
	}

	/********************************************************************************
	OUTPUT THE FILTERED DATA, OMITTING ANY PADDING
	********************************************************************************/
	if(setverb==1) fprintf(stderr,"\toutputting filtered data...\n");
	if(setoutpad==0) { start=0; stop=n1; }
	if(setoutpad==1) { start=0; stop=n2; }
	if(setdemean==2)
		for(ii=start;ii<stop;ii++) printf("%g\n",data1[ii]+mean);
	else
		for(ii=start;ii<stop;ii++) printf("%g\n",data1[ii]);

	free(data1);
	exit(0);

}
