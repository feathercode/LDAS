#!/bin/bash
# <TAGS>programming ldas</TAGS>
thisprog=`basename "$0"`
tempfile="temp_"$thisprog
tempfolder="/home/$USER/temp_LDAS_install"

# colours for use with optional error messages
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
bar="################################################################################"

################################################################################
# INTIAL VARIABLE DEFINITIONS
################################################################################
# for most scripts...
thisprog=`basename "$0"`
progpath=$(dirname $(readlink -f "$0"))
progbase1=$(echo $thisprog | awk -F - '{print toupper($NF)}')
allopts=$@

tempfile="temp_"$thisprog #"."$$"."
startdir=$(pwd)
start_time=$(date +'%s.%3N')
date0=$(date)

setsource="https://github.com/johnwilldonicely/LDAS/"
setscope="local"
setdest="/home/$USER/bin/"
setrc="/home/$USER/.bashrc"
filezip="LDAS-master.zip"
setfilezip=""
setverb="1"
setclean="1"

################################################################################
# DEFINE CHECK FUNCTION: CALL FORMAT: status=$(func_check)
################################################################################
function func_check () {
	status="OK"

	# check if dependency is installed - pandoc
	if [ "$(command -v pandoc)" == "" ] ; then status="WARNING" ; echo -e "\t--- Warning: pandoc is not installed on this machine: cannot convert to HTML\n" > $tempfile".status" ; fi

	# check presence and readability of /opt/LDAS/bin
	in1=$setdest/bin
	if [ ! -e $in1 ] ; then status="NOINSTALL" ; echo -e "\t--- Warning: missing $in1 , please run $thisprog install\n" > $tempfile".status" ; fi
	writeable=$(xs-progpermission $USER $in1 | awk '{print $2}')
	if [ "$writeable" == "no" ] ; then status="PERMISSION" ; echo -e "\t--- Warning: user $USER is not permitted to write to $in1\n" > $tempfile".status" ; fi

	echo $status # this returns to the calling function
}

################################################################################
# DEFINE PERMISSION FUNCTION: CALL FORMAT: status=$(func_permission $path yes|no)
################################################################################
function func_permission () {
	# READ THE ARGUMENTS
	zpath=$1 # the path to check
	zerror=$2 # "yes" if fail triggers error message + exit
	# DETERMINE BASIC INFO
	zaccess="no"
	zinfo=( $(stat -L -c "0%a %G %U" $zpath) ) # Use -L to get information about the target of a symlink, not the link itself
	zperm=${zinfo[0]}
	zgroup=${zinfo[1]}
	zowner=${zinfo[2]}
	# DETERMINE WRITE-ACCESS LEVEL
	if (( ($zperm & 0002) != 0 )); then 	# everyone has access
		zaccess="yes everyone"
	elif (( ($zperm & 0020) != 0 )); then 	# some group has write access. Is setuser in that group?
		gs=( $(groups $USER) )
		for g in "${gs[@]}"; do
			if [[ $zgroup == $g ]]; then zaccess="yes group" ; break ; fi
		done
	elif (( ($zperm & 0200) != 0 )); then # The owner has write access. Does the setuser own the file?
		[[ $USER == $zowner ]] && zaccess="yes owner"
	fi
	# HANDLE ERROR MESSAGES IF REQUIRED
	if [ "$zaccess" == "no" ] && [ "$zerror" == "yes" ] ; then
		echo -e "$RED--- Error ["$thisprog"]: $USER has no write-permission for $zpath"
		echo -e "\tConsider using \"--scope local\" to install to the user's bin folder"
		echo -e "\t... or, install as superuser"
		echo -e "\t... or, use sudo to temporarily give write access"
		echo -e "$NC"
		exit
	else
		echo "permission= "$zaccess
	fi
}

################################################################################
# PRINT INSTRUCTIONS IF NO ARGUMENTS ARE GIVEN
################################################################################
if [ $# -lt 1 ]; then
	echo
	echo "--------------------------------------------------------------------------------"
	echo $thisprog": LDAS installation script"
	echo "USAGE: $thisprog [mode] [options]"
	echo "	[mode]: operating mode (install or compile)"
	echo "		install: "
	echo "			- full install from GitHub (default) or a .zip archive"
	echo "			- check operating system & permissions"
	echo "			- update \$PATH variable"
	echo "			- check dependencies"
	echo "			- create bin folder"
	echo "		update: "
	echo "			- update from a .zip archive"
	echo "			- extract a zip archive of LDAS into $setdest"
	echo "		compile: "
	echo "			- re-compile code after install or GitHub update"
	echo "			- check presence of source folder and contents"
	echo "			- check bin folder is present, clear executable content"
	echo "			- compile all xe-* programs"
	echo "			- update all manuals"
	echo "VALID OPTIONS (defaults in []):"
	echo "	--zip: install LDAS from this zip-file [$setfilezip]"
	echo "		- if unset, use \"git clone\" to get the latest repo from GitHub"
	echo "	--scope: local (current user) or gloabl (all users) [$setscope]"
	echo "	--dest: destination for repository [$setdest]"
	echo "	--verb: verbose output (0=NO 1=YES) [$setverb]"
	echo "	--clean: remove temporary files (0=NO 1=YES) [$setclean]"
	echo "EXAMPLE: "
	echo "	"$thisprog" install"
	echo "--------------------------------------------------------------------------------"
	echo
	exit
fi

########################################################################################
# INPUT FILE(S) AND REQUIRED ARGUMENT HANDLING
########################################################################################
setmode=$1 ; shift
if [ "$setmode" != "update" ] && [ "$setmode" != "install" ] && [ "$setmode" != "compile" ] ; then
	echo -e "\n--- Error ["$thisprog"]: invalid mode ($setmode) - must be \"update\" or \"install\" or \"compile\"\n"
	exit
fi


########################################################################################
# OPTIONAL ARGUMENT HANDLING
########################################################################################
vs="v:c:" ; vl="scope:,dest:,zip:,verb:,clean:"
y=$(getopt -o $vs -l $vl -n "" -- "$@" 2>&1 > /dev/null)
if [ "$y" != "" ] ; then { echo -e "\n--- Error ["$thisprog"]"$y"\n" ; exit ; }
else eval set -- $(getopt -o $vs -l $vl -n "" -- "$@") ; fi
while [ $# -gt 0 ] ; do
	case $1 in
		--scope ) setscope=$2 ; shift ;;
		--zip ) setfilezip=$2 ; shift ;;
		--dest ) setdest=$2 ; shift ;;
		-v | --verb ) setverb=$2 ; shift ;;
		-c | --clean ) setclean=$2 ; shift ;;
		-- ) shift ; break ;;
		* ) ;;
	esac
	shift
done
if [ "$setverb" != "0" ] && [ "$setverb" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --verb ($setverb) -  must be 0 or 1\n" ;  exit; } ; fi
if [ "$setclean" != "0" ] && [ "$setclean" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --clean ($setclean) -  must be 0 or 1\n" ;  exit; } ; fi

if [ "$setclean" == "1" ] ; then
	if [ "$tempfolder" != "" ] ; then rm -rf $tempfolder ; fi
fi

# DETERMINE LINUX VERSION AND REPORT
distro=$(lsb_release -a | grep "Distributor ID:" | cut -f 2)
release=$(lsb_release -a | grep "Release:" | cut -f 2)
echo -e "\n"$bar"\nLinux distro: $distro $release\n"

# DETERMINE DESTINATION DEPENDING ON SELECTED SCOPE
# local= current user only, global= all users
if [ "$setscope" == "local" ] ; then
	setdest="/home/$USER/bin/"
	setrc="/home/$USER/.bashrc"
elif [ "$setscope" == "global" ] ; then
	setdest="/opt/"
	setrc="/etc/profile"
	# check permissions
	func_permission $setdest "yes"
	func_permission $setrc "yes"
else
	echo -e "\n--- Error ["$thisprog"]: invalid --scope ($setscope) -  must be \"local\" or \"global\"\n" ;  exit;
fi



########################################################################################
# MODE-1: INSTALL
########################################################################################
if [ "$setmode" == "install" ] ; then

	# CHECK IF DEPENDENCIES ARE INSTALLED
	dep="git" ; if [ "$(command -v $dep)" == "" ] ; then
		echo -e "\t--- Warning:$GREEN$dep$NC not installed- install or updates might fail"
		echo -e "\t\t - attempting to install $dep as sudo..."
		sudo yum install $dep -y
	fi
	dep="gs" ; if [ "$(command -v $dep)" == "" ] ; then
		echo -e "\t--- Warning:$GREEN$dep$NC not installed- graphics handling might fail"
		echo -e "\t\t - attempting to install $dep as sudo..."
		sudo yum install $dep -y
	fi
	de="dos2unix"; if [ "$(command -v $dep)" == "" ] ; then
		echo -e "\t--- Warning:$GREEN$dep$NC not installed- some scripts might fail"
		echo -e "\t\t - attempting to install $dep as sudo..."
		sudo yum install $dep -y
	fi
	dep="nano" ; if [ "$(command -v $dep)" == "" ] ; then
		echo -e "\t--- Warning:$GREEN$dep$NC not installed- manuals might not be viewable"
		echo -e "\t\t - attempting to install $dep as sudo..."
		sudo yum install $dep -y
	fi
	dep="pandoc" ; if [ "$(command -v $dep)" == "" ] ; then
		echo -e "\t--- Warning: $GREEN$dep$NC not installed- some manuals might not be rendered"
		echo -e "\t\t - attempting to install $dep as sudo..."
		sudo yum install $dep -y
	fi


# NOTE THAT R IS NOT ACTUALLY REQUIRED BUT RECOMMENDED - REMOVE FROM SOURCE FOLDER
# PANDOC MAY ALSO REQUIRE LATEX DEPENDENCIES? - SEE IF THERE IS A NO-LATED MD-to-PDF CONVERSION
# CHECK THAT CURRENT FOLDER IS NOT $DEST AND IS WRITEABLE
# CHECK THAT $DEST IS WRITEABLE
# ??? CHECK THAT GIT IS INSTALLED IF --SETZIP == ""
# ??? CHECK THAT LOCAL LDAS FOLDER DOESN'T ALREADY EXIST

	# RETRIEVE OR EXTRACT LDAS TO TEMP FOLDER
	mkdir -p $tempfolder
	if [ "$setclean" == "1" ] && [ "$tempfolder" != "" ] ; then rm -rf $tempfolder/* ; fi

	echo "--------------------------------------------------------------------------------"
	if [ "$setfilezip" != "" ] ; then
		echo -e "Extracting LDAS from $setfilezip ..."
		unzip -oq $setfilezip -d $tempfolder
		# find the most recent LDAS folder created
		z=$(ls -dt1 $tempfolder/*LDAS*/ | head -n 1 | awk -F / '{print $(NF-1)}' )
		# rename to LDAS
		mv $tempfolder/$z $tempfolder/LDAS
		mkdir $tempfolder/LDAS/bin
	else
		rm -f $tempfile".error"
		git clone $setsource $tempfolder/LDAS 2>&1 | tee $tempfile".error"
		z=$(grep fatal: $tempfile".error")
		if [ "$z" ] ; then { echo -e "$RED--- Error ["$thisprog"]: $z\n"$NC ; rm -f $tempfile".error" ;  exit ; } fi
		mkdir $tempfolder/LDAS/bin
	fi

	echo "--------------------------------------------------------------------------------"
	echo -e "CREATING DESTINATION DIRECTORIES IN $setdest ..."

ls -l
exit
	sudo mkdir -p $setdest
	sudo chown -R $USER:$USER $setdest
	mkdir -p $setdest/bin


	if [ -d "$setdest" ] ; then
		cd $setdest ; setdest=$(pwd) ; cd $startdir
	else


		{ echo -e "\n--- Error ["$thisprog"]: invalid destination (--des $setdest) - does   must be 0 or 1\n" ;  exit; } ; fi
	fi
	exit

	echo



	echo "--------------------------------------------------------------------------------"
	echo -e "UNZIPPING $setfilezip TO $tempfolder..."
	unzip -oq $setfilezip -d $tempfolder
exit
	echo "--------------------------------------------------------------------------------"
	echo -e "COPYING PROGRAMS TO $setdest..."
	# determine the subfolder from the zipfile containing the code
	source=$(ls -1dt $tempfolder/* | head -n 1)
	cp -a $source/* $setdest/

	echo "--------------------------------------------------------------------------------"
	echo -e "MAKING SCRIPTS EXECUTABLE..."
        chmod a+x $setdest/xs-*
        chmod a+x $setdest/xp-*


	z=$(grep -s '$PATH:'$setdest /etc/profile | head -n 1)
	if [ "$z" == "" ] ; then
		echo "--------------------------------------------------------------------------------"
		echo -e "UPDATING \$PATH VARIABLE FOR ALL USERS ($profile)..."
		template=$setdest"/docs/templates/ldas_profile.txt"
		sudo sh -c "cat $template >> /etc/profile"
	fi

	z=$(grep -s LDAS /etc/nanorc | head -n 1)
	if [ "$z" == "" ] ; then
		echo "--------------------------------------------------------------------------------"
		echo -e "CONFIGURING NANO SYNTAX-HIGHLIGHTING FOR MARKDOWN FILES..."
		template=$setdest"/docs/templates/ldas_nanorc.txt"
		sudo sh -c "cat $template >> /etc/nanorc"
	fi


	{ echo -e "$GREEN\nNOTE: now run $thisprog compile$NC\n" ;  exit; }
fi

########################################################################################
# MODE-2: UPDATE
########################################################################################
if [ "$setmode" == "update" ] ; then

	echo "--------------------------------------------------------------------------------"
	echo -e "UNZIPPING $setfilezip TO $tempfolder..."

	sudo mkdir -p $setdest
	sudo chown -R $USER:$USER $setdest
	unzip -oq $setfilezip -d $tempfolder

	echo "--------------------------------------------------------------------------------"
	echo -e "COPYING PROGRAMS TO $setdest..."
	# determine the subfolder from the zipfile containing the code
	source=$(ls -1dt $tempfolder/* | head -n 1)
	cp -a $source/* $setdest/

	echo "--------------------------------------------------------------------------------"
	echo -e "MAKING SCRIPTS EXECUTABLE..."
	chmod a+x $setdest/xs-*
	chmod a+x $setdest/xp-*

	{ echo -e "$GREEN\nNOTE: now run $thisprog compile$NC\n" ;  exit; }

fi


########################################################################################
# MODE-3: COMPILE
########################################################################################
if [ "$setmode" == "compile" ] ; then

	status=$(func_check)
	echo "status-check: "$status
	if [ "$status" == "NOINSTALL" ] || [ "$status" == "PERMISSION" ] ; then cat $tempfile".status" ; exit ; fi

	echo "--------------------------------------------------------------------------------"
	echo "COMPILING PROGRAMS..."
	rm -f $setdest/bin/xe-*
	cd $setdest/source
	xs-progcompile "xe-*.c"

	echo "--------------------------------------------------------------------------------"
	echo "UPDATING TAGS-SUMMARY FILE..."
	xs-progtag html | awk '{print "\t"$0}'

	echo "--------------------------------------------------------------------------------"
	echo "UPDATING MANUALS..."
	if [ "$(command -v pandoc)" != "" ] ; then
		list=$(xs-manual | xe-cut2 stdin available manuals: -s4 1 | tail -n +2 | xe-delimit stdin)
		for i in $list ; do xs-manual $i --make html 2>/dev/null | awk '{print "\t"$0}' ; done
	else
		echo -e "\n--- Warning ["$thisprog"]: pandoc is not installed on this machine: cannot create HTML versions of manuals\n"
	fi

fi


################################################################################
# REPORT, CLEANUP AND EXIT
################################################################################
if [ "$setverb" == "1" ] ; then
	end_time=$(date +'%s.%3N')
	s=$(echo $end_time $start_time | awk '{print $1-$2}' )
	m=$(echo $s | awk '{print ($1/60)}')
	echo -e "\n\tTime to finish job: "$s" seconds = "$m" minutes\n"
fi
if [ "$setclean" == "1" ] ; then
	if [ "$tempfile" != "" ] ; then rm -f $tempfile"_"* ; fi
fi
exit
