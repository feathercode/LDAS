#!/bin/bash
# <TAGS> epidemiology </TAGS>

################################################################################
# INTIAL VARIABLE DEFINITIONS
################################################################################
# for most scripts...
thisprog=`basename "$0"`
progpath=$(dirname $(readlink -f "$0"))
progbase1=$(echo $thisprog | awk -F - '{print toupper($NF)}')
allopts=$@
tempfile="temp_"$thisprog #"."$$"."
startdir=$(pwd)
start_time=$(date +'%s.%3N')
date0=$(date)
# colours for use with text printed to terminal
RED='\033[0;31m'	# for errors
PURPLE='\033[0;35m'	# for warnings
GREEN='\033[0;32m'	# for interactive text requiring input
NC='\033[0m' 		# to revert to default text colour
# options
setverb="0"
setclean="1"

seturl="https://opendata.ecdc.europa.eu/covid19/casedistribution/csv"
setcountries="United_Kingdom"
setmindeaths="0"
setmaxweeks="0"
setsmooth="7"
setopts1=""

################################################################################
# PRINT INSTRUCTIONS IF NO ARGUMENTS ARE GIVEN
################################################################################
if [ $# -lt 1 ]; then
	echo
	echo "--------------------------------------------------------------------------------"
	echo $thisprog": template BASH script"
	echo "USAGE: $thisprog [mode] [options]"
	echo "	[mode]: operating mode: down | proc | all"
	echo "		down: download latest data"
	echo "		process: process the data"
	echo "		all: all of the above"
	echo "VALID OPTIONS (defaults in []):"
	echo "	-d: minimum cumulative deaths (begin analysis) [$setmindeaths]"
	echo "	-w: maximum weeks since --mindeaths was reached (end analysis) [$setmaxweeks]"
	echo "	--countries: CSV list of countries to analyse [$setcountries]"
	echo "	--smooth: Gaussian smoothin gwindow (days) [$setsmooth]"
	echo "	--opts1: options (in quotes) o pass to xe-CORONA1 [unset]"
	echo "	--verb: verbose output (0=NO 1=YES) [$setverb]"
	echo "	--clean: remove temporary files (0=NO 1=YES) [$setclean]"
	echo "EXAMPLE: "
	echo "	list=\"United_Kingdom,France,Germany,Italy,Spain\""
	echo "	$thisprog all --countries \$list -d 10 -w 12"
	echo "--------------------------------------------------------------------------------"
	echo
	exit
fi

########################################################################################
# INPUT FILE(S) AND ARGUMENT HANDLING
########################################################################################
setmode=$1 ; shift
#if [ ! -e "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: missing file $infile\n" ;  exit; } ; fi
#if [ ! -s "$infile" ] ; then { echo -e "\n--- Error ["$thisprog"]: $infile is empty\n" ;  exit; } ; fi

vs="v:c:d:w:" ; vl="verb:,clean:,countries:,smooth,opts1:"
y=$(getopt -o $vs -l $vl -n "" -- "$@" 2>&1 > /dev/null)
if [ "$y" != "" ] ; then { echo -e "\n--- Error ["$thisprog"]"$y"\n" ; exit ; }
else eval set -- $(getopt -o $vs -l $vl -n "" -- "$@") ; fi
while [ $# -gt 0 ] ; do
	case $1 in
		-v | --verb ) setverb=$2 ; shift ;;
		-c | --clean ) setclean=$2 ; shift ;;
		-d ) setmindeaths=$2 ; shift ;;
		-w ) setmaxweeks=$2 ; shift ;;
		--countries ) setcountries=$2 ; shift ;;
		--smooth ) setsmooth=$2 ; shift ;;
		--opts1 ) setopts1=$2 ; shift ;;
		-- ) shift ; break ;;
		* ) ;;
	esac
	shift
done
if [ "$setverb" != "0" ] && [ "$setverb" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --verb ($setverb) -  must be 0 or 1\n" ;  exit; } ; fi
if [ "$setclean" != "0" ] && [ "$setclean" != "1" ] ; then { echo -e "\n--- Error ["$thisprog"]: invalid --clean ($setclean) -  must be 0 or 1\n" ;  exit; } ; fi
if [ $setverb == 1 ] ; then
	echo -e "--------------------------------------------------------------------------------\n"$thisprog" "$allopts"\n"
	echo -e "$date0"
fi

# convert weeks to days
let setmaxdays=$(echo "$setmaxweeks * 7" | bc | cut -f 1 -d .)


setmindeaths=$(echo $setopts1 | xe-getkey stdin "-mindeaths")
setmaxdays=$(echo $setopts1 | xe-getkey stdin "-maxdays")
setnormc=$(echo $setopts1 | xe-getkey stdin "-normc")
setnormd=$(echo $setopts1 | xe-getkey stdin "-normd")
setsmooth=$(echo $setopts1 | xe-getkey stdin "-smooth")

rm -f jj.*

################################################################################
# DOWNLOAD AND CREATE TEXT FILE
if [ "$setmode" == "all" ] || [ "$setmode" == "down" ] ; then

	# download file - rename from "csv" to covid_[date].csv
	# ...where date is derived from the flie timestamp
	wget -O csv -q --show-progress  $seturl
	basename="covid_"$(ls -l csv  --time-style="+%Y%m%d" | awk '{print $6}' | cut -f 1 -d /)
	mv csv $basename".csv"
	ls -l *.csv

	# save the header with renamed variables, convert commas and spaces
	head -n 1 $basename".csv" |
		xe-strsub1 stdin dateRep Date |
		xe-strsub1 stdin cases Cases |
		xe-strsub1 stdin deaths Deaths |
		xe-strsub1 stdin countriesAndTerritories Country |
		xe-strsub1 stdin geoId GeoID |
		xe-strsub1 stdin countryterritoryCode Code |
		xe-strsub1 stdin popData2018 Pop |
		xe-strsub1 stdin continentExp Continent |
		tr ',' '\t' |
		tr ' ' '_'  > jj.header
	tail -n +2 $basename".csv" |
		xe-strsub1 stdin ',,,' ',-,-,' | # pad e double-empty fields fr countries with no GeoID and Code
		xe-strsub1 stdin 'N/A' '-' | # treat as "missing"
		grep -v "Saint Eustatius" | # problematic due to comma in name
		tr ' ' '\t' |
		tr ',' '\t' |
		tr ' ' '_' |
		tr -d '"' > jj.1

	# sort the file by date and convert date format
	# the following is organised to be robust against changes in the order of the columns in the csv file
	listcols="Date,Cases,Deaths,Country,GeoID,Code,Pop,Continent"
	cat jj.header | xe-cut1 stdin $listcols > $basename".txt"
	cat jj.header jj.1 | #xe-dbmatch1 stdin GeoID -,N/A -m -2 |
		xe-cut1 stdin $listcols -o 1 |
		xe-dateconv1 stdin -h 0 -i 1 -o 4 |
		sort -k1,1n |
		xe-dateconv1 stdin -h 0 -i 4 -o 3  >> $basename".txt"

	echo "done downloading"
	head $basename.txt

	# Add Europe-wide data
	echo "Building Europe-wide data"
	xe-dbmatch1 $basename.txt Continent Europe > jj.europe1
	pop=$(xe-cut1 jj.europe1 GeoID,Pop -o 1 | sort -u | cut -f 2 | xe-math_sum1 stdin -long 1)
	listdates=$( xe-dbmatch1 $basename.txt Continent Europe | xe-cut1 stdin Date -o 1 | sort -u)
	for d in $listdates ; do
		cases=$(xe-dbmatch1 jj.europe1 Date $d -oc Cases | xe-math_sum1 stdin -long 1)
		deaths=$(xe-dbmatch1 jj.europe1 Date $d -oc Deaths | xe-math_sum1 stdin -long 1)
		echo -e "$d\t$cases\t$deaths\tEurope\tEU\tEUR\t$pop\tEurope" >> $basename.txt
	done

fi


################################################################################
# PROCESS THE LATEST DATA
if [ "$setmode" == "all" ] || [ "$setmode" == "proc" ] ; then

	echo
	listcountries=$(echo $setcountries | tr ',' ' ')

	########################################
	echo -n "...determine the latest data..."
	in1=$(ls -1 "covid_"????????".txt" | tail -n 1)
	echo "	input= "$in1

	########################################
	echo "...making all-countries code-table"
	xe-cut1 $in1 GeoID,Code,Country | (head -n 1 && tail -n +2 | sort -u )  > "table_countries_all.txt"

	########################################
	echo "...initialising the slopes file"
	echo -e "code\tslope1raw\tdays2dmax\tslope2norm\tdcurrent" > jj.slopes

	########################################
	echo "...running analysis for each country..."
	let count=0
	for country in $listcountries ; do

		let count=$count+1
		code=$(xe-dbmatch1 "table_countries_all.txt" Country $country -oc Code -o 1)
		pop=$(xe-dbmatch1 $in1 Country $country -oc Pop -o 1 | head -n 1)
		echo -e "\tCountry: "$country" ("$code")"

		#echo -e "\t\t...analyzing..."
		out2a=$tempfile"_block.txt"
		out2b="temp_xe-CORONA.txt"
		opts="-mindeaths $setmindeaths -maxdays $setmaxdays -normd 1 -normc 1 -pad 1 -out 2 $setopts1"

		# special case - eliminate second-peak for China
		if [ "$country" == "China" ] ; then opts=$opts" -peak2 1" ; fi

		if [ "$setverb" == "1" ] ; then echo -e "\t\txe-CORONA1 $in1 $country $opts" ; fi 
		xe-CORONA1 $in1 $country $opts $setopts1 > $out2a

		# save the slopes
		slope1raw=$(grep "Regression_rising_raw:" $out2b | xe-getkey stdin slope= | awk 'BEGIN{p='$pop'/1000000.0}{printf("%.3f",($1/p))}')
		slope2norm=$(grep "Regression_falling_normalised:" $out2b | xe-getkey stdin slope=)
		dmax=$(xe-getkey $out2b peak_deaths= | xe-math_round2 stdin -b 1)
		days2dmax=$(xe-getkey $out2b days_to_dmax=)
		dcurrent=$(xe-dbmatch1 temp_xs-CORONA1_block.txt Var Deaths -oc Count | tail -n 1)
		echo -e "$code\t$slope1raw\t$days2dmax\t$slope2norm\t$dcurrent" >> jj.slopes

		# make the groupnames table
		echo -e "group\tname" > "table_groupnames.txt"
		echo -e "0\tCases_Normalized" >> "table_groupnames.txt"
		echo -e "1\tDeaths" >> "table_groupnames.txt"
		echo -e "26\tFit_Rise:__$slope1norm" >> "table_groupnames.txt"
		echo -e "27\tFit_Fall:__$slope2norm" >> "table_groupnames.txt"

		#echo -e "\t\t...plotting..."
		xl="Weeks"
		yl="% of Peak"


		plotopts="-cg 1 -cx 4 -cy 3 -line 1 -pt histo -lwd 1 -xint 1 -xscale .4 -yscale .25 -vline 0 -xpad 0 -ypad 0 -hline $dcurrent"
		if [ "$setnormc" == "0" ] || [ "$setnormd" == "0" ] ; then
			plotop=$plotopts" -yint 10"
			yl="Daily Count"
		fi
		plotfile="plot_"$count".ps"
		plotlist=$plotlist" "$plotfile

		xe-plottable1 $out2a $plotopts -title "$country ($dmax)" -xlabel "$xl" -ylabel "$yl" -legend 1 -out $plotfile

		xe-strsub1 $plotfile "/c0 {0.0000 0.0000 0.0000} def" "/c0 {0.7 0.8 1.0} def" |
		xe-strsub1 stdin "/c1 {0.7500 0.1000 0.2000} def" "/c1 {0.9 0.5 0.5} def" > jjj
		mv jjj $plotfile

#		xs-plotmod1 $plotfile --out 1 --legend "table_groupnames.txt"

	done

	xe-plotmerge1 $plotlist -xo 75 -yo 680 -xmax 2 -ymax 4 -xinc 280 -yinc 200 -out "plot_summary"
	rm -f $plotlist
	xe-plotmerge2 $(ls plot_summary.???.ps) > plot_summary.ps
	rm -f plot_summary.???.ps


	# MAKE THE SLOPES PLOTS
	echo "...making slope-plots..."
	plotlist=""
	let ncountries=$(tail -n +2 jj.slopes | wc -l)
	xscale=$(echo "scale=3; 0.05 * $ncountries" | bc | awk '{s=$1; if(s>.9)s=.9; print s}')
	plotopts="-cx 1 -cg 3 -cy 3 -xint 1 -pt box -xscale $xscale -yscale .275 -legend 2 -pal inferno -frame 1 -font 8 "

	# 1. SLOPE OF RISE TO PEAK - DEATHS/MILLION/DAY
	# build a slopes data file sorted by ascending (steeper) slopes
	echo -e "\t- rising raw"
	in3="table_slopes_pre_raw.txt"
	xe-cut1 jj.slopes code,slope1raw > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > $in3
	# build a list of xpos/countrycode pairs for the xtics modification
	list=$(xe-cut1 $in3 xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_pre_raw.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 $in3 $plotopts -xlabel "Country" -ylabel "Daily/Day per 1M pop." -title "Initial impact (slope of rise in deaths) " -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1

	# 2. DAYS TO DEATH-MAX - a measure of speed of effective response
	echo -e "\t- days to d-max"
	in3="table_slopes_days_to_dmax.txt"
	xe-cut1 jj.slopes code,days2dmax > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > $in3
	list=$(xe-cut1 $in3 xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_pre_norm.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 $in3 $plotopts -xlabel "Country" -ylabel "Days from $setmindeaths to Peak Deaths" -title "Delay in response (duration of ascending deaths)" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1

	# 3. SLOPE OF FALL FROM PEAK
	# build a slopes data file sorted by ascending (lower) slopes, and converting to absolute values
	echo -e "\t- falling norm"
	in3="table_slopes_post_norm.txt"
	xe-cut1 jj.slopes code,slope2norm > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
#		xe-math_abs1 stdin -cy 3 |
		xe-math_round2 stdin -c 3 -b .01 > $in3
	list=$(xe-cut1 $in3 xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_slopes_post.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 $in3 $plotopts -xlabel "Country" -ylabel "% Normalised Peak / Day" -title "Persistence (slope of fall in deaths)" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1

	# 4. LAST CALCULATED DEATHS, %-OF-PEAK
	# build a data file sorted by ascending deaths
	echo -e "\t- latest deaths (% of peak)"
	in3="table_dcurrent.txt"
	xe-cut1 jj.slopes code,dcurrent > jj.temp
	(head -n 1 jj.temp | awk '{print "xpos\t"$0}' && tail -n +2 jj.temp | sort -k2,2n | awk '{print n++"\t"$0}' ) |
		xe-math_round2 stdin -c 3 -b .01 > $in3
	list=$(xe-cut1 $in3 xpos,code -o 1 | tr '\t' ',' | paste -s | tr '\t' ',')
	plotfile="plot_deaths_latest.ps"
	plotlist=$plotlist" "$plotfile
	xe-plottable1 $in3 $plotopts -xlabel "Country" -ylabel "% of Peak, $setmaxdays days" -title "$setmaxweeks-Week score (post-peak)" -out $plotfile
	xs-plotmod1 $plotfile --xtics $list --out 1


	# MERGE THE PLOTS
	xe-plotmerge1 $plotlist -xo 65 -xmax 1 -yinc 200 -out "plot_slopes"
	rm -f $plotlist


fi


################################################################################
# REPORT, CLEANUP AND EXIT
################################################################################
if [ "$setverb" == "1" ] ; then
	end_time=$(date +'%s.%3N')
	s=$(echo $end_time $start_time | awk '{print $1-$2}' )
	m=$(echo $s | awk '{print ($1/60)}')
	echo "	Time to finish job: "$s" seconds = "$m" minutes"
fi
if [ "$setclean" == "1" ] ; then
	if [ "$tempfile" != "" ] ; then rm -f $tempfile* ; fi
fi
exit
